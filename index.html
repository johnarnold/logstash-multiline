<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Logstash-multiline : An alterative version of Multiline filter which implements LRU cache with TTL and Max Size settings." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Logstash-multiline</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/johnarnold/logstash-multiline">View on GitHub</a>

          <h1 id="project_title">Logstash-multiline</h1>
          <h2 id="project_tagline">An alterative version of Multiline filter which implements LRU cache with TTL and Max Size settings.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/johnarnold/logstash-multiline/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/johnarnold/logstash-multiline/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="logstash-multiline" class="anchor" href="#logstash-multiline"><span class="octicon octicon-link"></span></a>logstash-multiline</h1>

<p>An alterative version of Multiline filter which implements LRU cache with TTL and Max Size settings.</p>

<p>The multiline filter is for combining multiple events from a single source
into the same event.  The multiline filter in master implements a hash table to store messages and then applies regex to determine whether a message should be joined with the "previous" or "next" in a stream.</p>

<p>I found that the original multiline.rb filter was problematic in certain scenarios where multiline messages are "transaction-oriented" and the stream_identity field is effectively unique for a given series of messages.  This can result in 1-or-more messages being received and the stream_identity never being used again.  In logstash pre-1.4.1 the filter flusher is disabled, so these messages could end up "stuck" in the filter and never output back to the pipeline.  Re-enabling the filter flusher mostly fixed that problem but there are cases where part of a message is received, then filter flusher runs, then the remainder message is received and this resulted in fragmented messages.</p>

<p>I re-wrote the multiline filter to implement a Least Recently Used cache, based on a modified version of the excellent cache.rb.  The library implements a maximum size (count) of messages in the cache, and a max TTL (seconds).  The filter flusher triggers a TTL check, and the max size only comes into play if the cache fills up and the filter tries to add more.   Evicted messages go back to the pipeline.</p>

<p>Configure your shipper.conf like:</p>

<p>multiline {</p>

<pre><code>pattern =&gt; "."

negate =&gt; false

what =&gt; "streamcache"

stream_identity =&gt; "%{field1}.%{field2}"

cache_ttl =&gt; 2

cache_size =&gt; 50000
</code></pre>

<p>}</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Logstash-multiline maintained by <a href="https://github.com/johnarnold">johnarnold</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
